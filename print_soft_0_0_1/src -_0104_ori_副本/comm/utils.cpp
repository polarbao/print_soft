#include "utils.h"
//获取short类型的高字节
#define HI_OF_SHORT(X) (X >> 8)
//获取short类型的低字节
#define LO_OF_SHORT(X) (X & 0xFF)

Utils::Utils()
{

}

Utils::~Utils()
{

}

QByteArray Utils::Text2ByteArr(const QString& text)
{
	return text.toUtf8();
}

QString Utils::ByteArr2HexText(const QByteArray& arr)
{
	return arr.toHex().toUpper();
}

QByteArray Utils::HexText2ByteArr(const QString& hexText)
{
	return QByteArray::fromHex(hexText.toUtf8());
}

QByteArray Utils::Text2HexByteArr(const QString& text)
{
	QByteArray originalBytes = Text2ByteArr(text);
	return originalBytes.toHex();
}


bool Utils::CheckCRC(uchar* data, int datalen)
{
	ushort crc = MakeCRCCheck(data, datalen - 2);
	uchar lo = LO_OF_SHORT(crc);
	uchar hi = HI_OF_SHORT(crc);
	//包中数据crc也是先高字节，再低字节
	if (hi == data[datalen - 2] && lo == data[datalen - 1])
	{
		return true;
	}
	else
	{
		return false;
	}
}

ushort Utils::MakeCRCCheck(uchar* data, int datalen)
{
	unsigned char byCRCHi = 0xff;
	unsigned char byCRCLo = 0xff;
	unsigned char byIdx;
	unsigned short crc;
	while (datalen--)
	{
		byIdx = byCRCLo ^ *data++;
		byCRCLo = byCRCHi ^ gabyCRCHi[byIdx];
		byCRCHi = gabyCRCLo[byIdx];
	}
	crc = byCRCHi;
	crc <<= 8;
	crc += byCRCLo;
	return crc;
}

/**
 * @brief 将10000微米单位的字符串数据转换为4字节16进制数据
 * @param strData 输入字符串（例如"5"代表5×10000微米=50000微米）
 * @param isBigEndian 是否按大端序输出（设备通信默认大端，小端传false）
 * @param isMicronDirect 输入字符串是否直接是微米数（true：需÷10000；false：已是10000微米单位，直接用）
 * @return 4字节的16进制数据（QByteArray），转换失败返回空
 */
QByteArray Utils::MicroDisStrTo4BytesHex(const QString& strData, bool isBigEndian /*= true*/, bool isMicronDirect /*= true*/)
{
		// 步骤1：校验字符串是否为合法数字
		bool isOk = false;
		// 转double兼容小数（比如"5.5"代表55000微米）
		double micronValue = strData.toDouble(&isOk);
		if (!isOk) 
		{
			//qWarning() << "输入字符串不是合法数字：" << strData;
			return QByteArray();
		}

		// 步骤2：单位换算（转为10000微米为单位的数值）
		double unitValue = isMicronDirect ? (micronValue / 10000.0) : micronValue;

		// 步骤3：转换为32位整数（4字节范围），这里取整（按需调整：四舍五入/向上取整）
		// 无符号32位：0 ~ 4294967295；
		// 有符号32位：-2147483648 ~ 2147483647
		// 若需有符号，用int32_t：int32_t int32Value = static_cast<int32_t>(qRound(unitValue));
		uint32_t uint32Value = static_cast<uint32_t>(qRound(unitValue)); // 四舍五入取整

		// 步骤4：数值转4字节数组（处理大小端）
		QByteArray byteData;
		byteData.resize(4); // 固定4字节

		if (isBigEndian) 
		{
			// 大端序（高位在前）：0x12345678 → [0x12, 0x34, 0x56, 0x78]
			byteData[0] = (uint32Value >> 24) & 0xFF;
			byteData[1] = (uint32Value >> 16) & 0xFF;
			byteData[2] = (uint32Value >> 8) & 0xFF;
			byteData[3] = uint32Value & 0xFF;
		}
		else 
		{
			// 小端序（低位在前）：0x12345678 → [0x78, 0x56, 0x34, 0x12]
			byteData[0] = uint32Value & 0xFF;
			byteData[1] = (uint32Value >> 8) & 0xFF;
			byteData[2] = (uint32Value >> 16) & 0xFF;
			byteData[3] = (uint32Value >> 24) & 0xFF;
		}

		return byteData;
}

/**
 * @brief 处理逗号分隔的1~3个微米字符串，转换为拼接后的4/8/12字节QByteArray
 * @param commaStr 逗号分隔输入字符串（例："50000"、"50000,60000"、"50000,60000,70000"）
 * @param isBigEndian 是否大端序输出（所有数据字节序一致）
 * @param isMicronDirect 输入子字符串是否直接是微米数（true：÷10000；false：已是10000微米单位）
 * @return 拼接后的字节数组（4/8/12字节），转换失败返回空
 */
QByteArray Utils::MultiMicroDisStrTo12BytesHex(const QString& commaStr, bool isBigEndian /*= true*/, bool isMicronDirect /*= true*/)
{
	QByteArray resultBytes; // 最终拼接结果

	// 步骤1：按逗号分割字符串，并过滤空元素（处理"5,,6"、",5,6"这类无效输入）
	QStringList micronStrList = commaStr.split(',');

	// 步骤2：校验子字符串数量（1~3个）
	int strCount = micronStrList.count();
	if (strCount < 1 || strCount > 3) 
	{
		//qWarning() << "无效的子字符串数量，必须1~3个，当前：" << strCount;
		return QByteArray();
	}

	// 步骤3：遍历每个子字符串，逐个转换为4字节数组并拼接
	for (int i = 0; i < strCount; ++i) 
	{
		QString subStr = micronStrList.at(i).trimmed(); // 去除前后空格（处理" 50000 , 60000 "）
		QByteArray single4Bytes = MicroDisStrTo4BytesHex(subStr, isBigEndian, isMicronDirect);

		// 任意一个子字符串转换失败，整体返回空
		if (single4Bytes.isEmpty()) 
		{
			//qWarning() << "第" << (i + 1) << "个子字符串转换失败：" << subStr;
			return QByteArray();
		}

		// 拼接当前4字节数组到结果中
		resultBytes.append(single4Bytes);
	}

	//步骤4：（可选）若需要强制补全12字节（不足时补0），可启用以下代码
	while (resultBytes.size() < 12) 
	{
	    resultBytes.append(static_cast<char>(0x00)); // 补0填充至12字节
	}
	return resultBytes;
}

const uchar Utils::gabyCRCHi[256] = 
{
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
	0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
	0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,
	0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
	0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
	0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
	0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
	0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
	0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
	0x40
};

const uchar Utils::gabyCRCLo[256] = 
{
	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4,
	0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
	0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD,
	0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7,
	0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
	0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE,
	0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2,
	0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
	0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
	0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91,
	0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
	0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88,
	0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
	0x40
};

